import * as React from 'react';
import { Breakpoints } from '../helpers';
import { DesignTokenSizeEnum, styled } from '../theme-provider';
export { DesignTokenSizeEnum as LayoutRowGap };
export const LayoutConfigurations = {
    full: {
        [Breakpoints.default]: [{ name: 'a', columns: 24 }]
    },
    half: {
        [Breakpoints.default]: [{ name: 'a', columns: 24 }, { name: 'b', columns: 24 }],
        [Breakpoints.tablet]: [{ name: 'a', columns: 12 }, { name: 'b', columns: 12 }]
    }
};
const areaConfigIsPlaceholder = (areaConfig) => areaConfig.name !== '.';
// increase the number of areas in a configuration so it has at least [length] areas
export const createFullLayoutConfiguration = (config, length) => {
    const configWithoutEmptySpaces = config.filter(areaConfigIsPlaceholder);
    return Array.from({
        length: Math.ceil(length / configWithoutEmptySpaces.length) * config.length
    }, (_ignore, index) => {
        const name = config[index % config.length].name;
        const columns = config[index % config.length].columns;
        if (name === '.') {
            return {
                name,
                columns
            };
        }
        return {
            name: `${name}${Math.floor(index / config.length)}`,
            columns
        };
    });
};
// distribute configured areas into lines and resolve column numbers
export const createLayoutConfigurationLines = (config) => config.reduce((acc, area) => {
    const newAreas = new Array(area.columns).fill(area.name);
    if (!acc.length || acc[acc.length - 1].length + area.columns > 24) {
        acc.push(newAreas);
    }
    else {
        acc[acc.length - 1].push(...newAreas);
    }
    return acc;
}, []);
const StyledContainer = styled.div.withConfig({ displayName: "StyledContainer", componentId: "sc-6xo49d" }) `
	display: grid;
	max-width: ${Breakpoints.b2560}px;
	margin: auto;

	${props => Object.keys(props.appearance).map(breakpoint => {
    const config = props.appearance[breakpoint];
    const fullConfig = createFullLayoutConfiguration(config, props.length);
    const configLines = createLayoutConfigurationLines(fullConfig);
    const rule = `
					grid-template-columns: repeat(24, 1fr);
					grid-template-areas: ${configLines
        .map(line => `"${line.join(' ')}"`)
        .join(' ')};
				`;
    if (parseInt(breakpoint, 10) === Breakpoints.default) {
        return rule;
    }
    return `
				@media (min-width: ${breakpoint}px) {
					${rule}
				}
			`;
})}

	row-gap: ${props => props.rowGap && props.theme.size[props.rowGap]};
`;
StyledContainer.displayName = 'StyledContainer';
const getGridAreaForConfigAndChild = (config, index) => Object.keys(config).map(breakpoint => {
    const configForBreakpoint = config[breakpoint].filter(areaConfigIsPlaceholder);
    const configForDefaultBreakpoint = config[Breakpoints.default].filter(areaConfigIsPlaceholder);
    const rule = `grid-area: ${configForDefaultBreakpoint[index % configForBreakpoint.length].name}${Math.floor(index / configForBreakpoint.length)};`;
    if (parseInt(breakpoint, 10) === Breakpoints.default) {
        return rule;
    }
    return `
			@media (min-width: ${breakpoint}px) {
				${rule}
			}
		`;
});
const StyledChildWrapper = styled.div.withConfig({ displayName: "StyledChildWrapper", componentId: "sc-ybw8a0" }) `
	${props => {
    const { appearance, index = 0 } = props;
    return getGridAreaForConfigAndChild(appearance, index);
}};
	overflow: ${props => (props.allowOverflowingContent ? 'visible' : 'hidden')};
`;
StyledChildWrapper.displayName = 'StyledChildWrapper';
export const Layout = props => {
    const { children, rowGap, allowOverflowingContent, appearance = LayoutConfigurations.full } = props;
    const filteredChildren = React.Children.toArray(children).filter(React.isValidElement);
    if (filteredChildren.length === 0) {
        return null;
    }
    const wrappedChildren = filteredChildren.map((child, index) => {
        const key = child.key === null ? undefined : child.key;
        return (React.createElement(StyledChildWrapper, { appearance: appearance, key: key, index: index, allowOverflowingContent: allowOverflowingContent }, child));
    });
    return (React.createElement(StyledContainer, { appearance: appearance, rowGap: rowGap, length: filteredChildren.length }, wrappedChildren));
};
Layout.displayName = 'Layout';
