/* eslint-disable-next-line import/default */
import get from 'lodash.get';
import { warnWithTrace } from '../helpers/logger';
import { themeSet } from './example-theme-definitions';
import { createCSSVarName } from './create-css-var-name';
import { injectDesignTokensOption } from './inject-design-tokens-option';
import { deprecations } from './deprecations';
/**
 * TypeGuard for type `ThemeName`
 *
 * @param prop Some arbitrary component property
 */
function isThemeName(prop) {
    return typeof prop === 'string';
}
function getDesignTokenValue(propertyPath = '', optionsOverride) {
    if (!propertyPath) {
        warnWithTrace(`Design token value could not be found: ${propertyPath}`);
        return undefined;
    }
    const options = injectDesignTokensOption(optionsOverride);
    const designTokenValue = get(options.tokens, propertyPath);
    // array values, return css var instead
    // the assumption is that every array is a dynamic designToken
    if (Array.isArray(designTokenValue)) {
        return `var(${createCSSVarName(propertyPath)})`;
    }
    return typeof designTokenValue === 'string' ? designTokenValue : undefined;
}
function warnIfDeprecated(path) {
    deprecations.forEach(deprecation => {
        if (path.match(deprecation.condition)) {
            warnWithTrace(deprecation.message);
        }
    });
}
function addProxy(targetObject, getFallbackTheme = () => undefined, path) {
    return new Proxy(targetObject, {
        get: (target, key) => {
            if (typeof key !== 'string') {
                return undefined;
            }
            if (Object.hasOwnProperty.call(target, key)) {
                warnIfDeprecated(path ? `${path}.${key}` : `${key}`);
                return target[key];
            }
            const fallbackTheme = getFallbackTheme();
            return fallbackTheme && fallbackTheme[key];
        }
    });
}
function recursivelyAddProxies(targetObject, getFallbackTheme = () => undefined, path) {
    const result = {};
    Object.entries(targetObject).forEach(([key, value]) => {
        if (typeof value === 'object' && value) {
            result[key] = recursivelyAddProxies(value, () => {
                const fallbackTheme = getFallbackTheme();
                return fallbackTheme && fallbackTheme[key];
            }, path ? `${path}.${key}` : key);
        }
        else {
            result[key] = value;
        }
    });
    return addProxy(result, getFallbackTheme, path);
}
function resolveDesignTokenValues(theme) {
    const resolvedTheme = {};
    Object.entries(theme).forEach(([key, value]) => {
        if (value === null || value === undefined) {
            return;
        }
        if (typeof value === 'object') {
            resolvedTheme[key] = resolveDesignTokenValues(value) || {};
            return;
        }
        resolvedTheme[key] = getDesignTokenValue(value);
    });
    return resolvedTheme;
}
export function getTheme(currentTheme, newTheme) {
    const parentTheme = currentTheme && Object.keys(currentTheme).length > 0
        ? currentTheme
        : recursivelyAddProxies(resolveDesignTokenValues(themeSet.main));
    if (!newTheme) {
        return parentTheme;
    }
    const updatedTheme = resolveDesignTokenValues(isThemeName(newTheme) ? themeSet[newTheme] : newTheme);
    return recursivelyAddProxies(updatedTheme, () => parentTheme);
}
