import * as React from 'react';
import { CSSTransition } from 'react-transition-group';
import { withTheme } from 'styled-components';
import { Breakpoints, getColumnsWidthForBreakpoint, getGridColumn, hexColorToRgba } from '../helpers';
import { css, styled } from '../theme-provider';
/**
 * Possible layer size variations
 */
export var FocusLayerSize;
(function (FocusLayerSize) {
    /** small layer */
    FocusLayerSize["A"] = "A";
    /** big layer */
    FocusLayerSize["B"] = "B";
})(FocusLayerSize || (FocusLayerSize = {}));
/**
 * Create a box shadow depending on a shadow color
 *
 * @param themeShadowColor The color of the drop shadow as provided by the current theme
 */
const createCssBoxShadow = (themeShadowColor) => {
    const defaultBoxShadow = 'box-shadow: initial;';
    if (!themeShadowColor) {
        return defaultBoxShadow;
    }
    const darkShadowColor = hexColorToRgba(themeShadowColor, 0.1);
    const lightShadowColor = hexColorToRgba(themeShadowColor, 0.05);
    // intentionally used hard coded px values here since they aren't theme-related and probably don't need a reusable variable
    return `box-shadow: 0 8px 32px 0 ${darkShadowColor}, 0 16px 48px 0 ${lightShadowColor};`;
};
const animationClassName = 'animation';
const animationTimeout = (props) => props.theme.animation.duration.layer;
const animationTimingFunction = (props) => props.theme.animation.timingFunction.in;
const baseTransform = 'translate(-50%, -50%)';
function calcLayerHeight(spacing) {
    return `calc(100% - ${spacing} * 2);`;
}
const StyledLayer = styled.div.withConfig({ displayName: "StyledLayer", componentId: "sc-ku0g94" }) `
	position: absolute;
	top: 50%;
	left: 50%;

	overflow-y: auto;
	-webkit-overflow-scrolling: touch;
	${props => css `
		max-height: ${calcLayerHeight(props.theme.size.static200)};

		@media (min-width: ${Breakpoints.b560}px) {
			max-height: ${calcLayerHeight(props.theme.size.static300)};
		}

		@media (min-width: ${Breakpoints.b1600}px) {
			max-height: ${calcLayerHeight(props.theme.size.static400)};
		}

		@media (min-width: ${Breakpoints.b2560}px) {
			max-height: ${calcLayerHeight(props.theme.size.static510)};
		}

		${props.size === 'A' &&
    `width: ${getGridColumn(22)};

					@media (min-width: ${Breakpoints.b560}px) {
						width: ${getGridColumn(20)};
					}
					@media (min-width: ${Breakpoints.b960}px) {
						width: ${getGridColumn(16)};
					}
					@media (min-width: ${Breakpoints.b1280}px) {
						width: ${getGridColumn(14)};
					}
					@media (min-width: ${Breakpoints.b1600}px) {
						width: ${getGridColumn(12)};
					}
					@media (min-width: ${Breakpoints.b1920}px) {
						width: ${getGridColumn(10)};
					}
					@media (min-width: ${Breakpoints.b2560}px) {
						width: ${getColumnsWidthForBreakpoint(10, Breakpoints.b2560)};
					}
				`}
		${props.size === 'B' &&
    `width: ${getGridColumn(22)};

					@media (min-width: ${Breakpoints.b560}px) {
						width: ${getGridColumn(20)};
					}
					@media (min-width: ${Breakpoints.b960}px) {
						width: ${getGridColumn(16)};
					}
					@media (min-width: ${Breakpoints.b1600}px) {
						width: ${getGridColumn(14)};
					}
					@media (min-width: ${Breakpoints.b1920}px) {
						width: ${getGridColumn(12)};
					}
					@media (min-width: ${Breakpoints.b2560}px) {
						width: ${getColumnsWidthForBreakpoint(12, Breakpoints.b2560)};
					}
				`}
	`}

	background-color: ${props => props.theme.global.backgroundColor};
	${props => createCssBoxShadow(props.theme.shadowColor)};

	opacity: 1;
	transform: ${baseTransform} translateY(0);

	transition: opacity ${props => animationTimeout(props)} ${props => animationTimingFunction(props)}, transform ${props => animationTimeout(props)} ${props => animationTimingFunction(props)};

	&.${animationClassName}-exit {
		opacity: 1;
		transform: ${baseTransform} translateY(0);
	}

	&.${animationClassName}-enter,
		&.${animationClassName}-exit-active,
		&.${animationClassName}-exit-done {
		opacity: 0;
		transform: ${baseTransform}
			translateY(${props => props.theme.size.static500});
	}

	// this must be separate from the animation-exit definition because the order in the CSS must be in a specific order
	// for the animation to work and some of the values for the animation are breakpoint specific.
	// * <name>-<state> => breakpoint specific for enter
	// * <name>-<state>-active => breakpoint specific for exit
	// * <name>-<state>-done (if needed) => breakpoint specific for exit
	&.${animationClassName}-enter-active {
		opacity: 1;
		transform: ${baseTransform} translateY(0);
	}
`;
const InternalFocusLayer = props => {
    const { active, ariaLabelledBy, children, in: visible, onExited, size, scrollElementRef } = props;
    return (React.createElement(CSSTransition, { classNames: animationClassName, onExited: onExited, in: visible, timeout: parseInt(animationTimeout(props) || '0', 10) },
        React.createElement(StyledLayer, { role: "dialog", "aria-modal": active, "aria-labelledby": ariaLabelledBy, size: size, ref: scrollElementRef }, children)));
};
export const FocusLayer = withTheme(InternalFocusLayer);
