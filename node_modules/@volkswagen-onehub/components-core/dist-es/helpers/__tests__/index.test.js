import { Breakpoints, compareBreakpoints, getColumnsWidthForBreakpoint, getGridColumn, hexColorToRgba } from '../index';
describe('helpers', () => {
    describe('compareBreakpoints', () => {
        test('identifies "default" as the smaller breakpoint', () => {
            expect(compareBreakpoints(Breakpoints.default, Breakpoints.b560)).toBeLessThan(0);
            expect(compareBreakpoints(Breakpoints.b1280, Breakpoints.default)).toBeGreaterThan(0);
            expect(compareBreakpoints(Breakpoints.default, `${Breakpoints.b1600}`)).toBeLessThan(0);
            expect(compareBreakpoints(`${Breakpoints.b960}`, Breakpoints.default)).toBeGreaterThan(0);
        });
        test('identifies two "default" breakpoints as equal', () => {
            expect(compareBreakpoints(Breakpoints.default, Breakpoints.default)).toBe(0);
        });
        describe('identifies the smaller of two regular breakpoints', () => {
            test('when passed as numbers', () => {
                expect(compareBreakpoints(Breakpoints.b560, Breakpoints.b1280)).toBeLessThan(0);
            });
            test('when passed as strings', () => {
                expect(compareBreakpoints(`${Breakpoints.b560}`, `${Breakpoints.b1280}`)).toBeLessThan(0);
            });
        });
        describe('identifies the larger of two regular breakpoints', () => {
            test('when passed as numbers', () => {
                expect(compareBreakpoints(Breakpoints.b1280, Breakpoints.b560)).toBeGreaterThan(0);
            });
            test('when passed as strings', () => {
                expect(compareBreakpoints(`${Breakpoints.b1280}`, `${Breakpoints.b560}`)).toBeGreaterThan(0);
            });
        });
        describe('identifies two equal regular breakpoints', () => {
            test('when passed as numbers', () => {
                expect(compareBreakpoints(Breakpoints.b560, Breakpoints.b560)).toBe(0);
            });
            test('when passed as strings', () => {
                expect(compareBreakpoints(`${Breakpoints.b560}`, `${Breakpoints.b560}`)).toBe(0);
            });
        });
    });
    describe('getGridColumn', () => {
        test('getGridColumn(0)', () => {
            expect(getGridColumn(0)).toBe('0vw');
        });
        test('getGridColumn(11)', () => {
            expect(getGridColumn(11)).toBe('45.83vw');
        });
        test('getGridColumn(24)', () => {
            expect(getGridColumn(24)).toBe('100vw');
        });
        test('getGridColumn(-1)', () => {
            expect(() => getGridColumn(-1)).toThrowError();
        });
        test('getGridColumn(25)', () => {
            expect(() => getGridColumn(25)).toThrowError();
        });
        test('getGridColumn(1.4)', () => {
            expect(() => getGridColumn(1.4)).toThrowError();
        });
    });
    describe('getColumnsWidthForBreakpoint', () => {
        test('getColumnsWidthForBreakpoint(0, Breakpoints.max)', () => {
            expect(getColumnsWidthForBreakpoint(0, Breakpoints.max)).toBe('0px');
        });
        test('getColumnsWidthForBreakpoint(11, Breakpoints.max)', () => {
            expect(getColumnsWidthForBreakpoint(11, Breakpoints.max)).toBe('880px');
        });
        test('getColumnsWidthForBreakpoint(24, Breakpoints.max)', () => {
            expect(getColumnsWidthForBreakpoint(24, Breakpoints.max)).toBe('1920px');
        });
        test('getColumnsWidthForBreakpoint(-1, Breakpoints.max)', () => {
            expect(() => getColumnsWidthForBreakpoint(-1, Breakpoints.max)).toThrowError();
        });
        test('getColumnsWidthForBreakpoint(25, Breakpoints.max)', () => {
            expect(() => getColumnsWidthForBreakpoint(25, Breakpoints.max)).toThrowError();
        });
        test('getColumnsWidthForBreakpoint(1.4, Breakpoints.max)', () => {
            expect(() => getColumnsWidthForBreakpoint(1.4, Breakpoints.max)).toThrowError();
        });
    });
    describe('hexColorToRgba', () => {
        test('returns fallback value 1 if passed alpha value is undefined', () => {
            expect(hexColorToRgba('#fff')).toBe('rgba(255,255,255,1)');
            expect(hexColorToRgba('#fff', undefined)).toBe('rgba(255,255,255,1)');
        });
        test('returns fallback alpha value 1 if passed value is invalid', () => {
            expect(hexColorToRgba('#fff', -1)).toBe('rgba(255,255,255,1)');
            expect(hexColorToRgba('#fff', 1.5)).toBe('rgba(255,255,255,1)');
        });
        test('returns fallback rgba value (transparent) if passed hex is invalid', () => {
            expect(hexColorToRgba('#fafaa', 1)).toBe('rgba(0,0,0,0)');
            expect(hexColorToRgba('#FF', 1)).toBe('rgba(0,0,0,0)');
            expect(hexColorToRgba('abc')).toBe('rgba(0,0,0,0)');
            expect(hexColorToRgba('#010101000', 0)).toBe('rgba(0,0,0,0)');
        });
        test('returns fallback rgba value if passed hex is invalid', () => {
            expect(hexColorToRgba('wurst')).toBe('rgba(0,0,0,0)');
        });
        test('returns given fallback option if passed hex is invalid', () => {
            expect(hexColorToRgba('wurst', { alpha: 0.3 })).toBe('rgba(0,0,0,0.3)');
        });
        test('returns fallback alpha if passed hex and alpha are invalid', () => {
            expect(hexColorToRgba('wurst', { alpha: 7 })).toBe('rgba(0,0,0,0)');
        });
        test('returns fallback rgb and alpha if passed hex and alpha are invalid', () => {
            expect(hexColorToRgba('wurst', { alpha: 7, rgbFallback: { r: 1, g: 2, b: 3 } })).toBe('rgba(1,2,3,0)');
        });
        test('returns fallback rgb and alpha if passed hex is invalid', () => {
            expect(hexColorToRgba('wurst', {
                alpha: 0.3,
                rgbFallback: { r: 1, g: 2, b: 3 }
            })).toBe('rgba(1,2,3,0.3)');
        });
        test('returns fallback rgba if passed hex and alpha are invalid', () => {
            expect(hexColorToRgba('wurst', {
                alpha: 7,
                rgbFallback: { r: 1, g: 2, b: 3 },
                rgbaFallback: 'initial'
            })).toBe('initial');
        });
        test('returns fallback rgba if passed hex is invalid', () => {
            expect(hexColorToRgba('wurst', {
                alpha: 0.3,
                rgbFallback: { r: 1, g: 2, b: 3 },
                rgbaFallback: 'initial'
            })).toBe('initial');
        });
        test('returns correct hex -> rgba converted values for valid inputs', () => {
            expect(hexColorToRgba('#000000', 0.1)).toBe('rgba(0,0,0,0.1)');
            expect(hexColorToRgba('#FFF', 0.05)).toBe('rgba(255,255,255,0.05)');
            expect(hexColorToRgba('#fafafa', 0.3)).toBe('rgba(250,250,250,0.3)');
            expect(hexColorToRgba('#ABA')).toBe('rgba(170,187,170,1)');
        });
    });
});
