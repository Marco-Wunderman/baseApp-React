import * as React from 'react';
import { CSSTransition } from 'react-transition-group';
import { withTheme } from 'styled-components';
import { Breakpoints, getColumnsWidthForBreakpoint, getGridColumn, hexColorToRgba } from '../helpers';
import { styled } from '../theme-provider';
const createCssBoxShadow = (themeShadowColor) => {
    const defaultBoxShadow = 'box-shadow: initial;';
    if (!themeShadowColor) {
        return defaultBoxShadow;
    }
    const darkShadowColor = hexColorToRgba(themeShadowColor, 0.1);
    const lightShadowColor = hexColorToRgba(themeShadowColor, 0.05);
    // intentionally used hard coded px values here since they aren't theme-related and probably don't need a reusable variable
    return `box-shadow: 0 8px 32px 0 ${darkShadowColor}, 0 16px 48px 0 ${lightShadowColor};`;
};
const animationClassName = 'animation';
const StyledScrollWrapper = styled.div.withConfig({ displayName: "StyledScrollWrapper", componentId: "sc-10pydn7" }) `
	position: fixed;
	top: 0;
	right: 0;
	bottom: 0;
	left: 0;
	overflow: auto;
	-webkit-overflow-scrolling: touch;

	transition: ${props => {
    const duration = props.theme.animation.duration.layer;
    const timingFunction = props.theme.animation.timingFunction.in;
    return `transform ${duration} ${timingFunction}`;
}};

	&.${animationClassName}-exit {
		transform: translateY(0);
	}

	&.${animationClassName}-enter,
		&.${animationClassName}-exit-active,
		&.${animationClassName}-exit-done {
		transform: translateY(100%);
	}

	// this must be separate from the animation-exit definition because the order in the CSS must be in a specific order
	// for the animation to work and some of the values for the animation are breakpoint specific.
	// * <name>-<state> => breakpoint specific for enter
	// * <name>-<state>-active => breakpoint specific for exit
	// * <name>-<state>-done (if needed) => breakpoint specific for exit
	&.${animationClassName}-enter-active {
		transform: translateY(0);
	}

	// transform must be reset after animation is done, to make position fixed inside layer work properly
	&.${animationClassName}-enter-done {
		transform: none;
	}
`;
const StyledLayer = styled.div.withConfig({ displayName: "StyledLayer", componentId: "sc-17grtnp" }) `
	height: auto;
	width: ${getGridColumn(22)};
	max-width: ${getColumnsWidthForBreakpoint(22, Breakpoints.max)};
	margin-top: ${props => props.theme.size.dynamic0350};
	margin-right: auto;
	margin-left: auto;
	background-color: ${props => props.theme.global.backgroundColor};

	/* re-enable pointer-events that where disabled in wrapping component */
	pointer-events: auto;

	${props => createCssBoxShadow(props.theme.shadowColor)};
`;
/*
    The StyledScrollWrapper needs to be as big as the screen to allow the scroll behaviour
    with empty space above the content. But this StyledScrollWrapper prevents click events from targeting
    the ShimLayer which should be a sibling of this layer.
    (This is only a issue in chrome: https://bugs.chromium.org/p/chromium/issues/detail?id=818444)
    This function allows us to have a scroll wrapper that is as big as the whole screen.
*/
function preventClickCapture(event) {
    const target = event.currentTarget;
    target.style.pointerEvents = 'none';
    const newTarget = document.elementFromPoint(event.clientX, event.clientY);
    if (newTarget) {
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        newTarget.click();
    }
    target.style.pointerEvents = '';
}
function InternalContentLayer(props) {
    const { active, ariaLabelledBy, children, in: visible, onExited, scrollElementRef } = props;
    return (React.createElement(CSSTransition, { classNames: animationClassName, onExited: onExited, in: visible, timeout: parseInt(props.theme.animation.duration.layer || '0', 10) },
        React.createElement(StyledScrollWrapper, { onClick: preventClickCapture, ref: scrollElementRef },
            React.createElement(StyledLayer, { role: "dialog", "aria-modal": active, "aria-labelledby": ariaLabelledBy, 
                // The propagation of the events needs to be stopped here to prevent the
                // StyledScrollWrapper to detect a click for child elements
                onClick: event => event.stopPropagation() }, children))));
}
export const ContentLayer = withTheme(InternalContentLayer);
