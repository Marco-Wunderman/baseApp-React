import * as React from 'react';
import { CSSTransition } from 'react-transition-group';
import { withTheme } from 'styled-components';
import { Breakpoints, getColumnsWidthForBreakpoint, getGridColumn, hexColorToRgba } from '../helpers';
import { ThemeProvider, styled } from '../theme-provider';
/**
 * Create a box shadow depending on a shadow color
 *
 * @param themeShadowColor The color of the drop shadow as provided by the current theme
 */
const createCssBoxShadow = (themeShadowColor) => {
    const defaultBoxShadow = 'box-shadow: initial;';
    if (!themeShadowColor) {
        return defaultBoxShadow;
    }
    const darkShadowColor = hexColorToRgba(themeShadowColor, 0.1);
    const lightShadowColor = hexColorToRgba(themeShadowColor, 0.05);
    // intentionally used hard coded px values here since they aren't theme-related and probably don't need a reusable variable
    return `box-shadow: 0 8px 32px 0 ${darkShadowColor}, 0 16px 48px 0 ${lightShadowColor};`;
};
const animationClassName = 'animation';
const StyledLayer = styled.div.withConfig({ displayName: "StyledLayer", componentId: "sc-1c58wk5" }) `
	position: relative;
	width: ${getGridColumn(20)};
	background: ${props => props.theme.interaction.recipe370.default};

	@media (min-width: ${Breakpoints.b560}px) {
		width: ${getGridColumn(18)};
	}

	@media (min-width: ${Breakpoints.b960}px) {
		width: ${getGridColumn(14)};
	}

	@media (min-width: ${Breakpoints.b1280}px) {
		width: ${getGridColumn(12)};
	}

	@media (min-width: ${Breakpoints.b1600}px) {
		width: ${getGridColumn(10)};
	}

	@media (min-width: ${Breakpoints.b1920}px) {
		width: ${getGridColumn(8)};
	}

	@media (min-width: ${Breakpoints.b2560}px) {
		width: ${getColumnsWidthForBreakpoint(6, Breakpoints.b2560)};
	}

	height: auto;
	max-height: calc(100vh - 2 * ${props => props.theme.size.dynamic0040});

	overflow: auto;
	-webkit-overflow-scrolling: touch;

	${props => createCssBoxShadow(props.theme.shadowColor)};

	opacity: 1;
	transform: translateY(0);

	transition: ${props => {
    const duration = props.theme.animation.duration.layer;
    const timingFunction = props.theme.animation.timingFunction.in;
    return `opacity ${duration} ${timingFunction}, transform ${duration} ${timingFunction}`;
}};

	&.${animationClassName}-exit {
		opacity: 1;
		transform: translateY(0);
	}

	&.${animationClassName}-enter,
		&.${animationClassName}-exit-active,
		&.${animationClassName}-exit-done {
		opacity: 0;
		transform: translateY(${props => props.theme.size.static500});
	}

	&.${animationClassName}-enter-active {
		opacity: 1;
		transform: translateY(0);
	}
`;
const InternalAlertLayer = props => {
    const { active, children, in: visible, onExited, role = 'alert', ariaLabel, ariaDescribedBy, ariaLabelledBy, scrollElementRef } = props;
    const timeout = parseInt(props.theme.animation.duration.layer || '0', 10);
    return (React.createElement(CSSTransition, { classNames: animationClassName, onExited: onExited, in: visible, timeout: timeout },
        React.createElement(StyledLayer, { ref: scrollElementRef, role: role, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, "aria-modal": active },
            React.createElement(ThemeProvider, { theme: "inverted" }, children))));
};
export const AlertLayer = withTheme(InternalAlertLayer);
