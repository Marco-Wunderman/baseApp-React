import { css } from 'styled-components';
import { createStylesForBreakpoints, isBreakpointConfig } from '../helpers/breakpoint';
import { createCSSVarName } from '../theme-provider/create-css-var-name';
import { ContainerWrap } from './definitions';
const directions = [
    'top',
    'right',
    'bottom',
    'left',
    'inlineStart',
    'inlineEnd'
];
function isDirectionalConfig(prop) {
    return (typeof prop === 'object' &&
        Object.keys(prop).every(key => directions.includes(key)));
}
// create CSS variables for all dynamic sizes for a given configuration (e.g. container gutter or padding)
export function createCSSVariablesForSizes(configOrSize, theme) {
    if (!configOrSize) {
        return '';
    }
    if (isDirectionalConfig(configOrSize)) {
        return directions
            .map(key => {
            const directionalConfigOrSize = configOrSize[key];
            return createCSSVariablesForSizes(directionalConfigOrSize, theme);
        })
            .join('');
    }
    if (isBreakpointConfig(configOrSize)) {
        const cssVar = createCSSVarName(configOrSize, 'container');
        return createStylesForBreakpoints(configOrSize, (size) => {
            const value = theme.size[size];
            return `${cssVar}: ${value};`;
        });
    }
    return '';
}
function createSpacing(gutter, theme) {
    if (isBreakpointConfig(gutter)) {
        const cssVar = createCSSVarName(gutter, 'container');
        return `var(${cssVar})`;
    }
    return theme.size[gutter];
}
export function createHorizontalAlignmentStyles(horizontalAlign) {
    if (!isBreakpointConfig(horizontalAlign)) {
        return `justify-content: ${horizontalAlign};`;
    }
    return createStylesForBreakpoints(horizontalAlign, breakpointHorizontalAlign => `justify-content: ${breakpointHorizontalAlign};`);
}
function wrapStyles(wrap, theme, gutter) {
    const spacing = (gutter && createSpacing(gutter, theme)) || '0px';
    switch (wrap) {
        case ContainerWrap.never:
            return `
				display: flex;
				flex-wrap: nowrap;
				flex-direction: row;
				margin: 0 calc(-0.5 * ${spacing});
			`;
        case ContainerWrap.always:
            return `
				display: block;
				flex-wrap: unset;
				flex-direction: unset;
				margin: 0 0 calc(-1 * ${spacing});
			`;
        default: {
            return `
				display: flex;
				flex-wrap: wrap;
				margin: 0 calc(-0.5 * ${spacing}) calc(-1 * ${spacing});
			`;
        }
    }
}
export function createWrapStyles(wrap = ContainerWrap.auto, theme, gutter) {
    if (!isBreakpointConfig(wrap)) {
        const x = wrapStyles(wrap, theme, gutter);
        return x;
    }
    return css `
		${createStylesForBreakpoints(wrap, (breakpointWrap) => wrapStyles(breakpointWrap, theme, gutter))}
	`;
}
function spacingBetweenElementsStyles(wrap, theme, gutter) {
    const spacing = (gutter && createSpacing(gutter, theme)) || '0px';
    switch (wrap) {
        case ContainerWrap.never:
            return `
				margin: 0 calc(${spacing} / 2);
			`;
        case ContainerWrap.always:
            return `
				margin: 0 0 ${spacing};
			`;
        default:
            return `
				margin: 0 calc(${spacing} / 2) ${spacing};
			`;
    }
}
export function createSpacingBetweenElementsStyles(wrap = ContainerWrap.auto, theme, gutter) {
    if (!isBreakpointConfig(wrap)) {
        return spacingBetweenElementsStyles(wrap, theme, gutter);
    }
    return css `
		${createStylesForBreakpoints(wrap, (breakpointWrap) => spacingBetweenElementsStyles(breakpointWrap, theme, gutter))}
	`;
}
export function createSpacingAroundElementsStyles(padding, theme, direction) {
    if (typeof padding === 'string' && theme) {
        return css `
			padding: ${theme.size[padding]};
		`;
    }
    if (isDirectionalConfig(padding)) {
        return css `
			padding: 0;
			${directions.reduce((acc, key) => {
            const directionalPadding = padding[key];
            const cssKey = key === 'inlineStart'
                ? 'inline-start'
                : key === 'inlineEnd'
                    ? 'inline-end'
                    : key;
            /**
             * TODO: We need to transform 'inline-start' and 'inline-end' to 'left' and 'right' for older
             * browsers. Once all browsers in owr browser matrix support 'inline-start' and 'inline-end' we can
             * remove the code for this transformation as well as the direction state in the container.
             */
            if (isBreakpointConfig(directionalPadding)) {
                const cssVar = createCSSVarName(directionalPadding, 'container');
                return `${acc}
						${key === 'inlineStart'
                    ? direction === 'rtl'
                        ? `padding-right: var(${cssVar});`
                        : `padding-left: var(${cssVar});`
                    : ''}
						${key === 'inlineEnd'
                    ? direction === 'rtl'
                        ? `padding-left: var(${cssVar});`
                        : `padding-right: var(${cssVar});`
                    : ''}
						padding-${cssKey}: var(${cssVar});
						`;
            }
            if (typeof directionalPadding === 'string' && theme) {
                return `${acc}
						${key === 'inlineStart'
                    ? direction === 'rtl'
                        ? `padding-right: ${theme.size[directionalPadding]};`
                        : `padding-left: ${theme.size[directionalPadding]};`
                    : ''}
						${key === 'inlineEnd'
                    ? direction === 'rtl'
                        ? `padding-left: ${theme.size[directionalPadding]};`
                        : `padding-right: ${theme.size[directionalPadding]};`
                    : ''}
						padding-${cssKey}: ${theme.size[directionalPadding]};
						`;
            }
            return acc;
        }, '')}
		`;
    }
    if (isBreakpointConfig(padding)) {
        const cssVar = createCSSVarName(padding, 'container');
        return css `
			padding: var(${cssVar});
		`;
    }
    return css `
		padding: 0;
	`;
}
