/* eslint-disable-next-line import/default */
import throttle from 'lodash.throttle';
import * as React from 'react';
import { CSSTransition } from 'react-transition-group';
import { withTheme } from 'styled-components';
import { findDOMNode } from 'react-dom';
import { Breakpoints, hexColorToRgba, getColumnsWidthForBreakpoint, getGridColumn } from '../helpers';
import { css, styled } from '../theme-provider';
export var InteractionLayerSize;
(function (InteractionLayerSize) {
    InteractionLayerSize["A"] = "A";
    InteractionLayerSize["B"] = "B";
    InteractionLayerSize["C"] = "C";
})(InteractionLayerSize || (InteractionLayerSize = {}));
const animationClassName = 'animation';
const LayerScrollContainer = styled.div.withConfig({ displayName: "LayerScrollContainer", componentId: "sc-1omkeja" }) `
	overflow-y: auto;
	-webkit-overflow-scrolling: touch;

	height: ${props => (props.windowHeight ? `${props.windowHeight}px` : '100%')};
`;
const StyledLayer = styled.div.withConfig({ displayName: "StyledLayer", componentId: "sc-1wno2sw" }) `
	background-color: ${props => props.theme.global.backgroundColor};

	position: fixed;
	top: 0;
	bottom: 0;
	${props => (props.direction === 'rtl' ? `left: 0;` : `right: 0;`)}

	box-shadow: ${props => {
    const themeShadowColor = props.theme.shadowColor || '#FFFFFF';
    const darkShadowColor = hexColorToRgba(themeShadowColor, 0.1);
    const lightShadowColor = hexColorToRgba(themeShadowColor, 0.05);
    return `0 8px 32px 0 ${darkShadowColor}, 0 16px 48px 0 ${lightShadowColor}`;
}};

	&.${animationClassName}-ltr-enter {
		transform: translateX(100%);
		right: 0;
	}
	&.${animationClassName}-ltr-enter-active {
		transform: translateX(0);
		right: 0;
		transition: ${props => {
    const duration = props.theme.animation.duration.layer;
    const timingFunction = props.theme.animation.timingFunction.in;
    return `transform ${duration} ${timingFunction}`;
}};
	}
	&.${animationClassName}-ltr-enter-done {
		right: 0;
	}
	&.${animationClassName}-ltr-exit {
		transform: translateX(0);
		right: 0;
	}
	&.${animationClassName}-ltr-exit-active {
		transform: translateX(100%);
		right: 0;
		transition: ${props => {
    const duration = props.theme.animation.duration.layer;
    const timingFunction = props.theme.animation.timingFunction.in;
    return `transform ${duration} ${timingFunction}`;
}};
	}

	&.${animationClassName}-rtl-enter {
		transform: translateX(-100%);
		left: 0;
	}
	&.${animationClassName}-rtl-enter-active {
		transform: translateX(0);
		left: 0;
		transition: ${props => {
    const duration = props.theme.animation.duration.layer;
    const timingFunction = props.theme.animation.timingFunction.in;
    return `transform ${duration} ${timingFunction}`;
}};
	}
	&.${animationClassName}-rtl-enter-done {
		left: 0;
	}
	&.${animationClassName}-rtl-exit {
		transform: translateX(0);
		left: 0;
	}
	&.${animationClassName}-rtl-exit-active {
		transform: translateX(-100%);
		left: 0;
		transition: ${props => {
    const duration = props.theme.animation.duration.layer;
    const timingFunction = props.theme.animation.timingFunction.in;
    return `transform ${duration} ${timingFunction}`;
}};
	}

	${props => css `${props.size === 'A' &&
    `width: ${getGridColumn(23)};

				@media (min-width: ${Breakpoints.b560}px) {
					width: ${getGridColumn(18)};
				}
				@media (min-width: ${Breakpoints.b960}px) {
					width: ${getGridColumn(12)};
				}
				@media (min-width: ${Breakpoints.b1280}px) {
					width: ${getGridColumn(8)};
				}
				@media (min-width: ${Breakpoints.b1600}px) {
					width: ${getGridColumn(6)};
				}
				@media (min-width: ${Breakpoints.b2560}px) {
					width: ${getColumnsWidthForBreakpoint(6, Breakpoints.b2560)};
				}
			`}
			${props.size === 'B' &&
    `width: ${getGridColumn(23)};

				@media (min-width: ${Breakpoints.b560}px) {
					width: ${getGridColumn(22)};
				}
				@media (min-width: ${Breakpoints.b960}px) {
					width: ${getGridColumn(20)};
				}
				@media (min-width: ${Breakpoints.b1600}px) {
					width: ${getGridColumn(19)};
				}
				@media (min-width: ${Breakpoints.b1920}px) {
					width: ${getGridColumn(18)};
				}
				@media (min-width: ${Breakpoints.b2560}px) {
					width: ${getColumnsWidthForBreakpoint(18, Breakpoints.b2560)};
				}
			`}
			${props.size === 'C' &&
    `width: ${getGridColumn(22)};

				@media (min-width: ${Breakpoints.b560}px) {
					width: ${getGridColumn(9)};
				}
				@media (min-width: ${Breakpoints.b2560}px) {
					width: ${getColumnsWidthForBreakpoint(9, Breakpoints.b2560)};
				}
			`}
			`};
`;
StyledLayer.displayName = 'StyledLayer';
const UnanimatedInteractionLayer = React.forwardRef((props, ref) => {
    const { active, children, direction, size, scrollElementRef, windowHeight } = props;
    const innerRef = ref || undefined;
    return (React.createElement(StyledLayer, { role: "dialog", "aria-modal": active, size: size, ref: innerRef, direction: direction },
        React.createElement(LayerScrollContainer, { ref: scrollElementRef, windowHeight: windowHeight }, children)));
});
UnanimatedInteractionLayer.displayName = 'UnanimatedInteractionLayer';
class InteractionLayerInternal extends React.PureComponent {
    constructor(props) {
        super(props);
        this.getWindowHeight = () => {
            const windowHeight = window.innerHeight;
            this.setState({ windowHeight });
        };
        this.resizeInteractionLayer = throttle(() => {
            this.getWindowHeight();
        }, 50);
        this.ref = React.createRef();
        this.state = {
            direction: undefined,
            windowHeight: window.innerHeight
        };
    }
    componentDidMount() {
        if (!this.ref || !this.ref.current || !window) {
            return;
        }
        // We need to use findDOMNode to ensure that we also get the
        // element from the reference in styled-components version v3.x.x.
        // After discontinuing the support for styled-components v3 we can remove
        // the `findDOMNode` and directly access the reference again.
        // eslint-disable-next-line react/no-find-dom-node
        const direction = window.getComputedStyle(findDOMNode(this.ref.current)).direction;
        if (direction === 'ltr' || direction === 'rtl') {
            this.setState({ direction });
        }
        window.addEventListener('resize', this.resizeInteractionLayer);
        this.resizeInteractionLayer();
    }
    componentWillUnmount() {
        window.removeEventListener('resize', this.resizeInteractionLayer);
    }
    render() {
        const { direction, windowHeight } = this.state;
        const { active, children, in: visible = true, key, onExited, scrollElementRef, size, theme } = this.props;
        const timeout = parseInt(theme.animation.duration.layer || '0', 10);
        return (React.createElement(CSSTransition, { classNames: `${animationClassName}-${direction}`, onExited: onExited, in: Boolean(visible && direction), timeout: timeout },
            React.createElement(UnanimatedInteractionLayer, { active: active, size: size, scrollElementRef: scrollElementRef, direction: direction, ref: this.ref, key: key, windowHeight: windowHeight }, children)));
    }
}
export const InteractionLayer = withTheme(InteractionLayerInternal);
