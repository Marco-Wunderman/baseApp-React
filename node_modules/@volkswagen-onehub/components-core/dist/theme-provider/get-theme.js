"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable-next-line import/default */
const lodash_get_1 = __importDefault(require("lodash.get"));
const logger_1 = require("../helpers/logger");
const example_theme_definitions_1 = require("./example-theme-definitions");
const create_css_var_name_1 = require("./create-css-var-name");
const inject_design_tokens_option_1 = require("./inject-design-tokens-option");
const deprecations_1 = require("./deprecations");
/**
 * TypeGuard for type `ThemeName`
 *
 * @param prop Some arbitrary component property
 */
function isThemeName(prop) {
    return typeof prop === 'string';
}
function getDesignTokenValue(propertyPath = '', optionsOverride) {
    if (!propertyPath) {
        logger_1.warnWithTrace(`Design token value could not be found: ${propertyPath}`);
        return undefined;
    }
    const options = inject_design_tokens_option_1.injectDesignTokensOption(optionsOverride);
    const designTokenValue = lodash_get_1.default(options.tokens, propertyPath);
    // array values, return css var instead
    // the assumption is that every array is a dynamic designToken
    if (Array.isArray(designTokenValue)) {
        return `var(${create_css_var_name_1.createCSSVarName(propertyPath)})`;
    }
    return typeof designTokenValue === 'string' ? designTokenValue : undefined;
}
function warnIfDeprecated(path) {
    deprecations_1.deprecations.forEach(deprecation => {
        if (path.match(deprecation.condition)) {
            logger_1.warnWithTrace(deprecation.message);
        }
    });
}
function addProxy(targetObject, getFallbackTheme = () => undefined, path) {
    return new Proxy(targetObject, {
        get: (target, key) => {
            if (typeof key !== 'string') {
                return undefined;
            }
            if (Object.hasOwnProperty.call(target, key)) {
                warnIfDeprecated(path ? `${path}.${key}` : `${key}`);
                return target[key];
            }
            const fallbackTheme = getFallbackTheme();
            return fallbackTheme && fallbackTheme[key];
        }
    });
}
function recursivelyAddProxies(targetObject, getFallbackTheme = () => undefined, path) {
    const result = {};
    Object.entries(targetObject).forEach(([key, value]) => {
        if (typeof value === 'object' && value) {
            result[key] = recursivelyAddProxies(value, () => {
                const fallbackTheme = getFallbackTheme();
                return fallbackTheme && fallbackTheme[key];
            }, path ? `${path}.${key}` : key);
        }
        else {
            result[key] = value;
        }
    });
    return addProxy(result, getFallbackTheme, path);
}
function resolveDesignTokenValues(theme) {
    const resolvedTheme = {};
    Object.entries(theme).forEach(([key, value]) => {
        if (value === null || value === undefined) {
            return;
        }
        if (typeof value === 'object') {
            resolvedTheme[key] = resolveDesignTokenValues(value) || {};
            return;
        }
        resolvedTheme[key] = getDesignTokenValue(value);
    });
    return resolvedTheme;
}
function getTheme(currentTheme, newTheme) {
    const parentTheme = currentTheme && Object.keys(currentTheme).length > 0
        ? currentTheme
        : recursivelyAddProxies(resolveDesignTokenValues(example_theme_definitions_1.themeSet.main));
    if (!newTheme) {
        return parentTheme;
    }
    const updatedTheme = resolveDesignTokenValues(isThemeName(newTheme) ? example_theme_definitions_1.themeSet[newTheme] : newTheme);
    return recursivelyAddProxies(updatedTheme, () => parentTheme);
}
exports.getTheme = getTheme;
