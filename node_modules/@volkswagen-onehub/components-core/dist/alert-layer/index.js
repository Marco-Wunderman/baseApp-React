"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const react_transition_group_1 = require("react-transition-group");
const styled_components_1 = require("styled-components");
const helpers_1 = require("../helpers");
const theme_provider_1 = require("../theme-provider");
/**
 * Create a box shadow depending on a shadow color
 *
 * @param themeShadowColor The color of the drop shadow as provided by the current theme
 */
const createCssBoxShadow = (themeShadowColor) => {
    const defaultBoxShadow = 'box-shadow: initial;';
    if (!themeShadowColor) {
        return defaultBoxShadow;
    }
    const darkShadowColor = helpers_1.hexColorToRgba(themeShadowColor, 0.1);
    const lightShadowColor = helpers_1.hexColorToRgba(themeShadowColor, 0.05);
    // intentionally used hard coded px values here since they aren't theme-related and probably don't need a reusable variable
    return `box-shadow: 0 8px 32px 0 ${darkShadowColor}, 0 16px 48px 0 ${lightShadowColor};`;
};
const animationClassName = 'animation';
const StyledLayer = theme_provider_1.styled.div.withConfig({ displayName: "StyledLayer", componentId: "sc-1c58wk5" }) `
	position: relative;
	width: ${helpers_1.getGridColumn(20)};
	background: ${props => props.theme.interaction.recipe370.default};

	@media (min-width: ${helpers_1.Breakpoints.b560}px) {
		width: ${helpers_1.getGridColumn(18)};
	}

	@media (min-width: ${helpers_1.Breakpoints.b960}px) {
		width: ${helpers_1.getGridColumn(14)};
	}

	@media (min-width: ${helpers_1.Breakpoints.b1280}px) {
		width: ${helpers_1.getGridColumn(12)};
	}

	@media (min-width: ${helpers_1.Breakpoints.b1600}px) {
		width: ${helpers_1.getGridColumn(10)};
	}

	@media (min-width: ${helpers_1.Breakpoints.b1920}px) {
		width: ${helpers_1.getGridColumn(8)};
	}

	@media (min-width: ${helpers_1.Breakpoints.b2560}px) {
		width: ${helpers_1.getColumnsWidthForBreakpoint(6, helpers_1.Breakpoints.b2560)};
	}

	height: auto;
	max-height: calc(100vh - 2 * ${props => props.theme.size.dynamic0040});

	overflow: auto;
	-webkit-overflow-scrolling: touch;

	${props => createCssBoxShadow(props.theme.shadowColor)};

	opacity: 1;
	transform: translateY(0);

	transition: ${props => {
    const duration = props.theme.animation.duration.layer;
    const timingFunction = props.theme.animation.timingFunction.in;
    return `opacity ${duration} ${timingFunction}, transform ${duration} ${timingFunction}`;
}};

	&.${animationClassName}-exit {
		opacity: 1;
		transform: translateY(0);
	}

	&.${animationClassName}-enter,
		&.${animationClassName}-exit-active,
		&.${animationClassName}-exit-done {
		opacity: 0;
		transform: translateY(${props => props.theme.size.static500});
	}

	&.${animationClassName}-enter-active {
		opacity: 1;
		transform: translateY(0);
	}
`;
const InternalAlertLayer = props => {
    const { active, children, in: visible, onExited, role = 'alert', ariaLabel, ariaDescribedBy, ariaLabelledBy, scrollElementRef } = props;
    const timeout = parseInt(props.theme.animation.duration.layer || '0', 10);
    return (React.createElement(react_transition_group_1.CSSTransition, { classNames: animationClassName, onExited: onExited, in: visible, timeout: timeout },
        React.createElement(StyledLayer, { ref: scrollElementRef, role: role, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, "aria-modal": active },
            React.createElement(theme_provider_1.ThemeProvider, { theme: "inverted" }, children))));
};
exports.AlertLayer = styled_components_1.withTheme(InternalAlertLayer);
