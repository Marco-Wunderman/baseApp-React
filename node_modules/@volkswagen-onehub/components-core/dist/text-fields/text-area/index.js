"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const shared_1 = require("../shared");
const text_field_wrapper_1 = require("../text-field-wrapper");
const utils_1 = require("../utils");
const theme_provider_1 = require("../../theme-provider");
// @todo get from theme
const borderSize = '2px';
const StyledTextArea = theme_provider_1.styled.textarea.withConfig({ displayName: "StyledTextArea", componentId: "sc-7xrm5a" }) `
	width: 100%;
	border-radius: 0;
	/* MinHeight is calculated via lineHeight and padding of the element. If any value is changed then you have to update it */
	min-height: calc(
		${props => props.theme.size.static150} * 2 +
			${props => props.theme.textAppearances.copy0200.lineHeight}
	);
	background: transparent;
	border: 0;
	color: ${utils_1.getColor};
	cursor: ${({ appearance }) => appearance === shared_1.TextAreaAppearance.Disabled ? 'not-allowed' : ''};
	padding: ${props => props.theme.size.static150} 0;
	border-bottom: ${({ appearance }) => appearance !== shared_1.TextAreaAppearance.ReadOnly && `${borderSize} solid`};
	border-color: ${utils_1.getStatusColor};
	outline: 0;
	font-size: ${props => props.theme.textAppearances.copy0200.fontSize};
	line-height: ${props => props.theme.textAppearances.copy0200.lineHeight};
	font-family: inherit;
	margin: ${props => props.theme.size.static100} 0;

	&:focus {
		border-color: ${props => {
    if (props.appearance === shared_1.TextAreaAppearance.Error) {
        return;
    }
    return props.theme.interaction.recipe150.checked;
}};
		outline-style: solid;
		outline-width: 1px;
		outline-color: ${props => props.theme.interaction.recipe100.active};
		outline-offset: 2px;

		& + div span {
			color: ${props => props.theme.border.color.primary};
		}

		~ ${text_field_wrapper_1.FloatingStyledLabelText} {
			transform: translateY(0);
			font-size: ${props => props.theme.textAppearances.copy100.fontSize};
		}
	}

	${props => props.valid &&
    theme_provider_1.css `
			& ~ ${text_field_wrapper_1.FloatingStyledLabelText} {
				transform: translateY(0);
				font-size: ${props.theme.textAppearances.copy100.fontSize};
			}
		`}
`;
class TextArea extends React.Component {
    constructor(props) {
        super(props);
        this.state = { valid: false };
        this.validateTextArea = this.validateTextArea.bind(this);
    }
    validateTextArea(event) {
        this.setState({ valid: Boolean(event.currentTarget.value) });
    }
    render() {
        const { label, appearance, name, onChange, onBlur, onFocus, value, errorText, placeholder, rows = 1, minLength, maxLength, required, isFloating } = this.props;
        const { valid } = this.state;
        return (React.createElement(text_field_wrapper_1.TextFieldWrapper, { appearance: appearance, label: label, maxLength: maxLength, errorText: errorText, required: required, value: value, isFloating: isFloating },
            React.createElement(StyledTextArea, { readOnly: appearance === shared_1.TextAreaAppearance.ReadOnly, disabled: appearance === shared_1.TextAreaAppearance.Disabled, rows: rows, appearance: appearance, minLength: minLength, name: name, onChange: onChange, onBlur: event => {
                    this.validateTextArea(event);
                    if (onBlur) {
                        onBlur(event);
                    }
                }, onFocus: onFocus, placeholder: placeholder, value: value, required: required, valid: valid })));
    }
}
exports.TextArea = TextArea;
