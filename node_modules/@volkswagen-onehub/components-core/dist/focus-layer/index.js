"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const react_transition_group_1 = require("react-transition-group");
const styled_components_1 = require("styled-components");
const helpers_1 = require("../helpers");
const theme_provider_1 = require("../theme-provider");
/**
 * Possible layer size variations
 */
var FocusLayerSize;
(function (FocusLayerSize) {
    /** small layer */
    FocusLayerSize["A"] = "A";
    /** big layer */
    FocusLayerSize["B"] = "B";
})(FocusLayerSize = exports.FocusLayerSize || (exports.FocusLayerSize = {}));
/**
 * Create a box shadow depending on a shadow color
 *
 * @param themeShadowColor The color of the drop shadow as provided by the current theme
 */
const createCssBoxShadow = (themeShadowColor) => {
    const defaultBoxShadow = 'box-shadow: initial;';
    if (!themeShadowColor) {
        return defaultBoxShadow;
    }
    const darkShadowColor = helpers_1.hexColorToRgba(themeShadowColor, 0.1);
    const lightShadowColor = helpers_1.hexColorToRgba(themeShadowColor, 0.05);
    // intentionally used hard coded px values here since they aren't theme-related and probably don't need a reusable variable
    return `box-shadow: 0 8px 32px 0 ${darkShadowColor}, 0 16px 48px 0 ${lightShadowColor};`;
};
const animationClassName = 'animation';
const animationTimeout = (props) => props.theme.animation.duration.layer;
const animationTimingFunction = (props) => props.theme.animation.timingFunction.in;
const baseTransform = 'translate(-50%, -50%)';
function calcLayerHeight(spacing) {
    return `calc(100% - ${spacing} * 2);`;
}
const StyledLayer = theme_provider_1.styled.div.withConfig({ displayName: "StyledLayer", componentId: "sc-ku0g94" }) `
	position: absolute;
	top: 50%;
	left: 50%;

	overflow-y: auto;
	-webkit-overflow-scrolling: touch;
	${props => theme_provider_1.css `
		max-height: ${calcLayerHeight(props.theme.size.static200)};

		@media (min-width: ${helpers_1.Breakpoints.b560}px) {
			max-height: ${calcLayerHeight(props.theme.size.static300)};
		}

		@media (min-width: ${helpers_1.Breakpoints.b1600}px) {
			max-height: ${calcLayerHeight(props.theme.size.static400)};
		}

		@media (min-width: ${helpers_1.Breakpoints.b2560}px) {
			max-height: ${calcLayerHeight(props.theme.size.static510)};
		}

		${props.size === 'A' &&
    `width: ${helpers_1.getGridColumn(22)};

					@media (min-width: ${helpers_1.Breakpoints.b560}px) {
						width: ${helpers_1.getGridColumn(20)};
					}
					@media (min-width: ${helpers_1.Breakpoints.b960}px) {
						width: ${helpers_1.getGridColumn(16)};
					}
					@media (min-width: ${helpers_1.Breakpoints.b1280}px) {
						width: ${helpers_1.getGridColumn(14)};
					}
					@media (min-width: ${helpers_1.Breakpoints.b1600}px) {
						width: ${helpers_1.getGridColumn(12)};
					}
					@media (min-width: ${helpers_1.Breakpoints.b1920}px) {
						width: ${helpers_1.getGridColumn(10)};
					}
					@media (min-width: ${helpers_1.Breakpoints.b2560}px) {
						width: ${helpers_1.getColumnsWidthForBreakpoint(10, helpers_1.Breakpoints.b2560)};
					}
				`}
		${props.size === 'B' &&
    `width: ${helpers_1.getGridColumn(22)};

					@media (min-width: ${helpers_1.Breakpoints.b560}px) {
						width: ${helpers_1.getGridColumn(20)};
					}
					@media (min-width: ${helpers_1.Breakpoints.b960}px) {
						width: ${helpers_1.getGridColumn(16)};
					}
					@media (min-width: ${helpers_1.Breakpoints.b1600}px) {
						width: ${helpers_1.getGridColumn(14)};
					}
					@media (min-width: ${helpers_1.Breakpoints.b1920}px) {
						width: ${helpers_1.getGridColumn(12)};
					}
					@media (min-width: ${helpers_1.Breakpoints.b2560}px) {
						width: ${helpers_1.getColumnsWidthForBreakpoint(12, helpers_1.Breakpoints.b2560)};
					}
				`}
	`}

	background-color: ${props => props.theme.global.backgroundColor};
	${props => createCssBoxShadow(props.theme.shadowColor)};

	opacity: 1;
	transform: ${baseTransform} translateY(0);

	transition: opacity ${props => animationTimeout(props)} ${props => animationTimingFunction(props)}, transform ${props => animationTimeout(props)} ${props => animationTimingFunction(props)};

	&.${animationClassName}-exit {
		opacity: 1;
		transform: ${baseTransform} translateY(0);
	}

	&.${animationClassName}-enter,
		&.${animationClassName}-exit-active,
		&.${animationClassName}-exit-done {
		opacity: 0;
		transform: ${baseTransform}
			translateY(${props => props.theme.size.static500});
	}

	// this must be separate from the animation-exit definition because the order in the CSS must be in a specific order
	// for the animation to work and some of the values for the animation are breakpoint specific.
	// * <name>-<state> => breakpoint specific for enter
	// * <name>-<state>-active => breakpoint specific for exit
	// * <name>-<state>-done (if needed) => breakpoint specific for exit
	&.${animationClassName}-enter-active {
		opacity: 1;
		transform: ${baseTransform} translateY(0);
	}
`;
const InternalFocusLayer = props => {
    const { active, ariaLabel, ariaDescribedBy, ariaLabelledBy, children, in: visible, onExited, size, scrollElementRef } = props;
    return (React.createElement(react_transition_group_1.CSSTransition, { classNames: animationClassName, onExited: onExited, in: visible, timeout: parseInt(animationTimeout(props) || '0', 10) },
        React.createElement(StyledLayer, { role: "dialog", "aria-modal": active, "aria-describedby": ariaDescribedBy, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, size: size, ref: scrollElementRef }, children)));
};
exports.FocusLayer = styled_components_1.withTheme(InternalFocusLayer);
