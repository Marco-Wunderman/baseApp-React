"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const ReactDOM = __importStar(require("react-dom"));
const theme_provider_1 = require("../theme-provider");
const text_1 = require("../text");
const helpers_1 = require("../helpers");
class Tabs extends React.Component {
    constructor(props) {
        super(props);
        this.tabsRef = React.createRef();
        this.state = {
            indicatorLeft: 0,
            indicatorWidth: 0,
            activeIndex: props.defaultIndex
        };
        this.tabRefs = Array.from({
            length: props.children.length
        }).map(() => React.createRef());
        this.handleClick = this.handleClick.bind(this);
        this.handleKeyUp = this.handleKeyUp.bind(this);
    }
    updateIndicatorBoundaries(activeIndex) {
        const { indicatorLeft, indicatorWidth } = this.state;
        const activeTab = this.tabRefs[activeIndex] || this.tabRefs[0];
        // We need to use findDOMNode to ensure that we also get the
        // element from the reference in styled-components version v3.x.x.
        // After discontinuing the support for styled-components v3 we can remove
        // the `findDOMNode` and directly access the reference again.
        // eslint-disable-next-line react/no-find-dom-node
        const activeTabDOMNode = ReactDOM.findDOMNode(activeTab.current);
        const activeTabRect = activeTabDOMNode && activeTabDOMNode.getBoundingClientRect();
        // We need to use findDOMNode to ensure that we also get the
        // element from the reference in styled-components version v3.x.x.
        // After discontinuing the support for styled-components v3 we can remove
        // the `findDOMNode` and directly access the reference again.
        // eslint-disable-next-line react/no-find-dom-node
        const tabsDOMNode = ReactDOM.findDOMNode(this.tabsRef.current);
        const tabsRect = tabsDOMNode && tabsDOMNode.getBoundingClientRect();
        const left = (activeTabRect && tabsRect && activeTabRect.left - tabsRect.left) || 0;
        const width = (activeTabRect && activeTabRect.width) || 0;
        if (indicatorLeft !== left || indicatorWidth !== width) {
            this.setState({
                indicatorLeft: left,
                indicatorWidth: width
            });
        }
    }
    updateFocus(activeIndex) {
        const activeTab = this.tabRefs[activeIndex] || this.tabRefs[0];
        // We need to use findDOMNode to ensure that we also get the
        // element from the reference in styled-components version v3.x.x.
        // After discontinuing the support for styled-components v3 we can remove
        // the `findDOMNode` and directly access the reference again.
        // eslint-disable-next-line react/no-find-dom-node
        const activeTabDOMNode = ReactDOM.findDOMNode(activeTab.current);
        if (!activeTabDOMNode) {
            return;
        }
        // focus is missing in Element type
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        activeTabDOMNode.focus();
    }
    componentDidMount() {
        const { defaultIndex } = this.props;
        this.updateIndicatorBoundaries(defaultIndex);
    }
    componentDidUpdate(prevProps, prevState) {
        const { defaultIndex } = this.props;
        const { activeIndex } = this.state;
        if (this.props.children !== prevProps.children) {
            this.updateIndicatorBoundaries(defaultIndex);
            this.setState({ activeIndex: defaultIndex });
        }
        if (activeIndex !== prevState.activeIndex) {
            this.updateIndicatorBoundaries(activeIndex);
        }
    }
    handleClick(event, activeIndex) {
        const { onChange } = this.props;
        event.preventDefault();
        this.setState({ activeIndex });
        onChange(activeIndex);
    }
    handleKeyUp(event) {
        const { children, onChange } = this.props;
        const { activeIndex: previousActiveIndex } = this.state;
        event.preventDefault();
        if (event.keyCode === 37) {
            const activeIndex = (previousActiveIndex - 1 + children.length) % children.length;
            this.setState({
                activeIndex
            });
            this.updateFocus(activeIndex);
            onChange(activeIndex);
        }
        else if (event.keyCode === 39) {
            const activeIndex = (previousActiveIndex + 1 + children.length) % children.length;
            this.setState({
                activeIndex
            });
            this.updateFocus(activeIndex);
            onChange(activeIndex);
        }
    }
    render() {
        const { children, idPrefix } = this.props;
        const { activeIndex } = this.state;
        const { indicatorLeft, indicatorWidth } = this.state;
        return (React.createElement(React.Fragment, null,
            React.createElement(StyledTabBar, { role: "tablist", ref: this.tabsRef, left: indicatorLeft, width: indicatorWidth, count: children.length }, children.map((tab, index) => (React.createElement(StyledTab, { role: "presentation", key: tab.key, id: `${idPrefix}-tab-${tab.key}`, "aria-controls": `${idPrefix}-content-${tab.key}`, index: index },
                React.createElement(StyledTabAnchor, { onClick: event => this.handleClick(event, index), tabIndex: activeIndex === index ? 0 : -1, ref: this.tabRefs[index], onKeyUp: this.handleKeyUp }, typeof tab.title === 'string' ? (React.createElement(text_1.Text, null, tab.title)) : (tab.title)))))),
            children.map((tab, index) => (React.createElement("div", { role: "tabpanel", hidden: index !== activeIndex, key: tab.key, id: `${idPrefix}-content-${tab.key}`, "aria-controls": `${idPrefix}-tab-${tab.key}` }, tab.content)))));
    }
}
Tabs.defaultProps = { defaultIndex: 0 };
exports.Tabs = Tabs;
const StyledTab = theme_provider_1.styled.li.withConfig({ displayName: "StyledTab", componentId: "sc-uzx9q3" }) `
	grid-area: ${props => String.fromCharCode(props.index + 65)};
`;
const tabBarIndicatorHeight = '2px';
const StyledTabBar = theme_provider_1.styled.ul.withConfig({ displayName: "StyledTabBar", componentId: "sc-1wtrart" }) `
	position: relative;
	display: grid;
	grid-template-columns:
		repeat(
			${props => props.count},
			max-content minmax(0, var(--size-dynamic0250))
		)
		auto;
	grid-template-areas: ${props => `"${Array.from({ length: props.count })
    .map((_e, col) => `${String.fromCharCode(col + 65)} .`)
    .join(' ')} ."`};

	margin: 0 0 ${props => props.theme.size.static250} 0;
	border-bottom: ${tabBarIndicatorHeight} solid
		${props => props.theme.interaction.recipe150.default};
	padding: 0;
	list-style: none;

	::after {
		content: '';
	}

	::before {
		transition: ${props => `transform ${props.theme.animation.timingFunction.cubicOut}
				${props.theme.animation.duration.tabIndicator}`};
		left: 0; /* basis for calculated position */
		width: 100px; /* basis for calculated width */
		transform-origin: left;
		content: '';
		position: absolute;
		bottom: -${tabBarIndicatorHeight};
		transform: ${props => `translateX(${props.left}px) scaleX(${props.width / 100})`};
		height: ${tabBarIndicatorHeight};
		background: ${props => props.theme.interaction.recipe150.checked};
	}
`;
const StyledTabAnchor = theme_provider_1.styled.button.withConfig({ displayName: "StyledTabAnchor", componentId: "sc-vul809" }) `
	display: inline-block;
	margin: 0;
	padding: 0;
	outline: none;
	border: none;
	background: transparent;
	padding-bottom: ${props => props.theme.size.static250};
	color: inherit;
	text-decoration: none;

	:focus {
		${props => helpers_1.createA11yOutlineStyles(props)}
	}
`;
