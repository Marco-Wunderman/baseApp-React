"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const helpers_1 = require("../helpers");
class BreakpointWrapper extends React.Component {
    constructor(props) {
        super(props);
        this.handleMatchMedia = (event) => {
            this.setState({ isVisible: event.matches });
        };
        let { min, max, ssrBreakpoint } = this.props;
        if (min === helpers_1.Breakpoints.default) {
            min = undefined;
        }
        if (max === helpers_1.Breakpoints.default) {
            max = undefined;
        }
        if (ssrBreakpoint === helpers_1.Breakpoints.default) {
            ssrBreakpoint = undefined;
        }
        const mediaQueryMin = min ? ` and (min-width: ${min}px)` : '';
        const mediaQueryMax = max ? ` and (max-width: ${max - 1}px)` : '';
        this.mediaQuery = `all${mediaQueryMin}${mediaQueryMax}`;
        let isVisible = false;
        if (min && max && ssrBreakpoint) {
            isVisible = min <= ssrBreakpoint && max > ssrBreakpoint;
        }
        else if (min && ssrBreakpoint) {
            isVisible = min <= ssrBreakpoint;
        }
        else if (max && ssrBreakpoint) {
            isVisible = max > ssrBreakpoint;
        }
        else if (ssrBreakpoint) {
            isVisible = true;
        }
        else if (!min) {
            isVisible = true;
        }
        this.state = {
            isVisible
        };
    }
    componentDidMount() {
        this.mediaQueryList = window.matchMedia(this.mediaQuery);
        this.setState({ isVisible: this.mediaQueryList.matches });
        if (!this.mediaQueryList.addEventListener) {
            // Fallback for Safari
            this.mediaQueryList.addListener(this.handleMatchMedia);
            return;
        }
        this.mediaQueryList.addEventListener('change', this.handleMatchMedia);
    }
    componentWillUnmount() {
        if (this.mediaQueryList) {
            if (this.mediaQueryList.removeEventListener) {
                this.mediaQueryList.removeEventListener('change', this.handleMatchMedia);
            }
            else {
                // Fallback for Safari
                this.mediaQueryList.removeListener(this.handleMatchMedia);
            }
        }
    }
    render() {
        const { children } = this.props;
        const { isVisible } = this.state;
        return (isVisible && React.createElement(React.Fragment, null, children)) || null;
    }
}
exports.BreakpointWrapper = BreakpointWrapper;
