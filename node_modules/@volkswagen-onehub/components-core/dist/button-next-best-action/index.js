"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const ReactDOM = __importStar(require("react-dom"));
const react_transition_group_1 = require("react-transition-group");
const styled_components_1 = require("styled-components");
const text_1 = require("../text");
const theme_provider_1 = require("../theme-provider");
const keyframesClosing = (props) => {
    return styled_components_1.keyframes `
		from {
			transform: translateX(0);
		}

		to {
			transform: ${props.direction === 'ltr'
        ? `translateX(
							-${parseInt(props.theme.size.static350, 10) +
            parseInt(props.theme.size.static300, 10) * 2}px
						)
						translateX(100%)`
        : `translateX(
							${parseInt(props.theme.size.static350, 10) +
            parseInt(props.theme.size.static300, 10) * 2}px
						)
						translateX(-100%)`};
		}
	`;
};
const keyframesOpening = (props) => {
    return styled_components_1.keyframes `
		from {
			transform: ${props.direction === 'ltr'
        ? `translateX(
							-${parseInt(props.theme.size.static350, 10) +
            parseInt(props.theme.size.static300, 10) * 2}px
						)
						translateX(100%)`
        : `translateX(
							${parseInt(props.theme.size.static350, 10) +
            parseInt(props.theme.size.static300, 10) * 2}px
						)
						translateX(-100%)`};
		}

		to {
			transform: translateX(0);
		}
	`;
};
const keyframesInitializing = styled_components_1.keyframes `
	0% {
		opacity: 0;
	}

	100% {
		opacity: 1;
	}
`;
const StyledOverflowWrapper = theme_provider_1.styled.div.withConfig({ displayName: "StyledOverflowWrapper", componentId: "sc-1pt9oer" }) `
	direction: ${props => props.direction};
	overflow: hidden;
	/* Safari does not correctly cut off overflowing content with only "overflow: hidden;" */
	clip-path: inset(0 0 0 0);
	border-radius: ${props => parseInt(props.theme.size.static350, 10) / 2 +
    parseInt(props.theme.size.static300, 10)}px; /* 1/2 height */
`;
const StyledTextWrapper = theme_provider_1.styled.div.withConfig({ displayName: "StyledTextWrapper", componentId: "sc-bublms" }) `
	${props => props.expanded
    ? theme_provider_1.css `
					animation: ${props.theme.animation.duration.nba} ${keyframesOpening} 1
						${props.theme.animation.timingFunction.cubicOut};
			  `
    : theme_provider_1.css `
					animation: ${props.theme.animation.duration.nba} ${keyframesClosing} 1
						${props.theme.animation.timingFunction.cubicOut};
			  `}
	transform: translateX(0);
	white-space: nowrap;
	transition:
		background-color
			${props => `${props.theme.animation.duration.nba} ${props.theme.animation.timingFunction.cubicOut}`},
		border-color
			${props => `${props.theme.animation.duration.nba} ${props.theme.animation.timingFunction.cubicOut}`};
	height: ${props => parseInt(props.theme.size.static350, 10) +
    parseInt(props.theme.size.static300, 10) *
        2}px; /* icon size plus top and bottom borders */
	${props => props.direction === 'rtl'
    ? theme_provider_1.css `
					padding-left: ${parseInt(props.theme.size.static350, 10) +
        parseInt(props.theme.size.static200, 10) +
        parseInt(props.theme.size.static300, 10)}px; /* icon size plus large outer and small inner border */
					padding-right: ${props.theme.size.static300};
			  `
    : theme_provider_1.css `
					padding-right: ${parseInt(props.theme.size.static350, 10) +
        parseInt(props.theme.size.static200, 10) +
        parseInt(props.theme.size.static300, 10)}px; /* icon size plus large outer and small inner border */
					padding-left: ${props.theme.size.static300};
			  `}

	border-radius: ${props => parseInt(props.theme.size.static350, 10) / 2 +
    parseInt(props.theme.size.static300, 10)}px; /* 1/2 height */
	background-color: ${props => props.theme.interaction.recipe250.default};
	flex: auto 0 0;
	display: flex;
	align-items: center;
`;
const StyledIconWrapper = theme_provider_1.styled.div.withConfig({ displayName: "StyledIconWrapper", componentId: "sc-1rs67cr" }) `
	height: ${props => parseInt(props.theme.size.static350, 10) +
    parseInt(props.theme.size.static300, 10) *
        2}px; /* icon size plus top and bottom borders */
	width: ${props => parseInt(props.theme.size.static350, 10) +
    parseInt(props.theme.size.static300, 10) * 2}px; /* same as height */
	border: ${props => props.theme.size.static300} solid;
	border-radius: ${props => parseInt(props.theme.size.static350, 10) / 2 +
    parseInt(props.theme.size.static300, 10)}px; /* 1/2 height */
	flex: auto 0 0;
	position: absolute;
	${props => props.direction === 'rtl'
    ? theme_provider_1.css `
					left: 0;
					border-color: transparent transparent transparent
						${props => props.theme.interaction.recipe250.default};
			  `
    : theme_provider_1.css `
					right: 0;
					border-color: transparent
						${props => props.theme.interaction.recipe250.default} transparent
						transparent;
			  `}
	display: flex;
	align-items: center;
	justify-content: center;
	transition: border-color
		${props => `${props.theme.animation.duration.nba} ${props.theme.animation.timingFunction.cubicOut}`};
`;
const StyledInnerIconWrapper = theme_provider_1.styled.div.withConfig({ displayName: "StyledInnerIconWrapper", componentId: "sc-1h40eto" }) `
	height: ${props => parseInt(props.theme.size.static350, 10) +
    parseInt(props.theme.size.static200, 10) *
        2}px; /* icon size plus top and bottom borders */
	width: ${props => parseInt(props.theme.size.static350, 10) +
    parseInt(props.theme.size.static200, 10) * 2}px; /* same as height */
	background-color: ${props => props.transitionState === 'entering'
    ? 'white'
    : props.theme.interaction.recipe250.default};
	border: ${props => props.theme.size.static200} solid;
	border-radius: ${props => parseInt(props.theme.size.static350, 10) / 2 +
    parseInt(props.theme.size.static200, 10)}px; /* 1/2 height */
	border-color: ${props => props.transitionState === 'entering'
    ? 'white'
    : props.theme.interaction.recipe250.default};
	line-height: 0;
	position: absolute;
	${props => props.direction === 'rtl'
    ? `
					right: -${props.theme.size.static200};
			  `
    : `
					left: -${props.theme.size.static200};
			  `}
	top: -${props => props.theme.size.static200};
	transition: opacity
			${props => `${props.theme.animation.duration.nba} ${props.theme.animation.timingFunction.cubicOut}`},
		transform
			${props => `${props.theme.animation.duration.nba} ${props.theme.animation.timingFunction.cubicOut}`},
		background-color
			${props => `${props.theme.animation.duration.nba} ${props.theme.animation.timingFunction.cubicOut}`},
		border-color
			${props => `${props.theme.animation.duration.nba} ${props.theme.animation.timingFunction.cubicOut}`};
	opacity: ${props => (props.transitionState === 'entered' ? 1 : 0)};
	transform: ${props => props.transitionState === 'entering'
    ? 'rotate(-90deg)'
    : props.transitionState === 'entered'
        ? 'rotate(0deg)'
        : 'rotate(90deg)'};
`;
const StyledButton = theme_provider_1.styled.button.withConfig({ displayName: "StyledButton", componentId: "sc-vl0af8" }) `
	/* We hide the element until the initial animations are done */
	animation: ${props => props.theme.animation.duration.nba} ${keyframesInitializing} 1 step-end;
	display: flex;
	${props => props.direction === 'rtl'
    ? theme_provider_1.css `
					margin-right: auto;
			  `
    : theme_provider_1.css `
					margin-left: auto;
			  `}
	max-width: ${props => parseInt(props.theme.size.static350, 10) +
    parseInt(props.theme.size.static300, 10) *
        2}px; /* icon size plus top and bottom borders */
	min-width: ${props => parseInt(props.theme.size.static350, 10) +
    parseInt(props.theme.size.static300, 10) *
        2}px; /* icon size plus top and bottom borders */
	padding: 0px;
	position: relative;
	transition: max-width 0s ease-in-out
		${props => props.theme.animation.duration.nba};
	box-shadow: none;
	appearance: none;
	border: none;
	cursor: pointer;
	color: ${props => props.theme.interaction.recipe300.default};
	background-color: transparent;

	max-width: ${props => props.expanded && '100vw'};
	transition: ${props => props.expanded && 'none'};

	::before {
		content: '';
		position: absolute;
		${props => props.direction === 'rtl'
    ? theme_provider_1.css `
						left: 0;
				  `
    : theme_provider_1.css `
						right: 0;
				  `}
		z-index: 1;
		width: ${props => parseInt(props.theme.size.static350, 10) +
    parseInt(props.theme.size.static300, 10) *
        2}px; /* icon size plus top and bottom borders */;
		height: 100%;
		border-radius: ${props => parseInt(props.theme.size.static350, 10) / 2 +
    parseInt(props.theme.size.static300, 10)}px; /* 1/2 height */
		transition: ${props => props.expanded
    ? 'none'
    : `width ${props.theme.animation.duration.nba} ${props.theme.animation.timingFunction.cubicOut}`};
		pointer-events: none;
	}

	:hover,
	:focus {
		transition: none;

		::before {
			width: 100%;
			background: ${props => props.theme.hoverIndicatorColor.filledElement.default};
		}

		max-width: ${props => props.expanded === undefined && '100vw'};

		${StyledTextWrapper} {
			${props => props.expanded === undefined &&
    theme_provider_1.css `
					animation: ${props.theme.animation.duration.nba} ${keyframesOpening} 1
						${props.theme.animation.timingFunction.cubicOut};
				`}
		}
	}


	:active {
		::before {
			background: ${props => props.theme.hoverIndicatorColor.filledElement.active};
		}
	}

	:focus {
		color: ${props => props.theme.interaction.recipe300.hover};
		outline: none;

		${StyledTextWrapper} {
			background-color: ${props => props.theme.interaction.recipe250.hover};
		}

		${StyledIconWrapper} {
			${props => props.direction === 'rtl'
    ? theme_provider_1.css `
							border-left-color: ${props => props.theme.interaction.recipe250.hover};
					  `
    : theme_provider_1.css `
							border-right-color: ${props => props.theme.interaction.recipe250.hover};
					  `}
		}

		${StyledInnerIconWrapper} {
			background-color: ${props => props.theme.interaction.recipe250.hover};
			border-color: ${props => props.theme.interaction.recipe250.hover};
		}

		::after {
			content: '';
			position: absolute;
			width: 100%;
			height: 100%;
			padding: 2px 0;
			border-width: 2px 0;
			border-color: ${props => props.theme.focusColor};
			border-style: solid;
			align-self: center;
			pointer-events: none;
		}
	}
`;
class NextBestActionButtonInternal extends React.Component {
    constructor(props) {
        super(props);
        this.handleClick = (e) => {
            const { action: { onClick = () => undefined } } = this.props;
            onClick(e);
        };
        this.ref = React.createRef();
        this.state = {
            direction: undefined
        };
    }
    componentDidMount() {
        const direction = this.ref &&
            this.ref.current &&
            window &&
            // We need to use findDOMNode to ensure that we also get the
            // element from the reference in styled-components version v3.x.x.
            // After discontinuing the support for styled-components v3 we can remove
            // the `findDOMNode` and directly access the reference again.
            // eslint-disable-next-line react/no-find-dom-node
            window.getComputedStyle(ReactDOM.findDOMNode(this.ref.current)).direction;
        if (direction === 'ltr' || direction === 'rtl') {
            this.setState({ direction });
        }
    }
    render() {
        const { action: { content, icon }, theme, expandContent } = this.props;
        const timeout = parseInt(theme.animation.duration.nba || '300', 10);
        const { direction } = this.state;
        return (React.createElement(StyledButton, { onClick: this.handleClick, expanded: expandContent, direction: direction, ref: this.ref || undefined },
            React.createElement(StyledOverflowWrapper, { expanded: expandContent, direction: direction },
                React.createElement(StyledTextWrapper, { direction: direction, expanded: expandContent },
                    React.createElement(text_1.Text, { color: text_1.TextColor.inherit }, content))),
            React.createElement(StyledIconWrapper, { direction: direction },
                React.createElement(react_transition_group_1.TransitionGroup, null,
                    React.createElement(react_transition_group_1.Transition, { timeout: { exit: timeout }, key: icon.key || undefined }, state => (React.createElement(StyledInnerIconWrapper, { transitionState: state, direction: direction }, icon)))))));
    }
}
exports.NextBestActionButton = styled_components_1.withTheme(NextBestActionButtonInternal);
