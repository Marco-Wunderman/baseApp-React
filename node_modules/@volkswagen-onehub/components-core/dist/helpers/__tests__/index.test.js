"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../index");
describe('helpers', () => {
    describe('compareBreakpoints', () => {
        test('identifies "default" as the smaller breakpoint', () => {
            expect(index_1.compareBreakpoints(index_1.Breakpoints.default, index_1.Breakpoints.b560)).toBeLessThan(0);
            expect(index_1.compareBreakpoints(index_1.Breakpoints.b1280, index_1.Breakpoints.default)).toBeGreaterThan(0);
            expect(index_1.compareBreakpoints(index_1.Breakpoints.default, `${index_1.Breakpoints.b1600}`)).toBeLessThan(0);
            expect(index_1.compareBreakpoints(`${index_1.Breakpoints.b960}`, index_1.Breakpoints.default)).toBeGreaterThan(0);
        });
        test('identifies two "default" breakpoints as equal', () => {
            expect(index_1.compareBreakpoints(index_1.Breakpoints.default, index_1.Breakpoints.default)).toBe(0);
        });
        describe('identifies the smaller of two regular breakpoints', () => {
            test('when passed as numbers', () => {
                expect(index_1.compareBreakpoints(index_1.Breakpoints.b560, index_1.Breakpoints.b1280)).toBeLessThan(0);
            });
            test('when passed as strings', () => {
                expect(index_1.compareBreakpoints(`${index_1.Breakpoints.b560}`, `${index_1.Breakpoints.b1280}`)).toBeLessThan(0);
            });
        });
        describe('identifies the larger of two regular breakpoints', () => {
            test('when passed as numbers', () => {
                expect(index_1.compareBreakpoints(index_1.Breakpoints.b1280, index_1.Breakpoints.b560)).toBeGreaterThan(0);
            });
            test('when passed as strings', () => {
                expect(index_1.compareBreakpoints(`${index_1.Breakpoints.b1280}`, `${index_1.Breakpoints.b560}`)).toBeGreaterThan(0);
            });
        });
        describe('identifies two equal regular breakpoints', () => {
            test('when passed as numbers', () => {
                expect(index_1.compareBreakpoints(index_1.Breakpoints.b560, index_1.Breakpoints.b560)).toBe(0);
            });
            test('when passed as strings', () => {
                expect(index_1.compareBreakpoints(`${index_1.Breakpoints.b560}`, `${index_1.Breakpoints.b560}`)).toBe(0);
            });
        });
    });
    describe('getGridColumn', () => {
        test('getGridColumn(0)', () => {
            expect(index_1.getGridColumn(0)).toBe('0vw');
        });
        test('getGridColumn(11)', () => {
            expect(index_1.getGridColumn(11)).toBe('45.83vw');
        });
        test('getGridColumn(24)', () => {
            expect(index_1.getGridColumn(24)).toBe('100vw');
        });
        test('getGridColumn(-1)', () => {
            expect(() => index_1.getGridColumn(-1)).toThrowError();
        });
        test('getGridColumn(25)', () => {
            expect(() => index_1.getGridColumn(25)).toThrowError();
        });
        test('getGridColumn(1.4)', () => {
            expect(() => index_1.getGridColumn(1.4)).toThrowError();
        });
    });
    describe('getColumnsWidthForBreakpoint', () => {
        test('getColumnsWidthForBreakpoint(0, Breakpoints.max)', () => {
            expect(index_1.getColumnsWidthForBreakpoint(0, index_1.Breakpoints.max)).toBe('0px');
        });
        test('getColumnsWidthForBreakpoint(11, Breakpoints.max)', () => {
            expect(index_1.getColumnsWidthForBreakpoint(11, index_1.Breakpoints.max)).toBe('880px');
        });
        test('getColumnsWidthForBreakpoint(24, Breakpoints.max)', () => {
            expect(index_1.getColumnsWidthForBreakpoint(24, index_1.Breakpoints.max)).toBe('1920px');
        });
        test('getColumnsWidthForBreakpoint(-1, Breakpoints.max)', () => {
            expect(() => index_1.getColumnsWidthForBreakpoint(-1, index_1.Breakpoints.max)).toThrowError();
        });
        test('getColumnsWidthForBreakpoint(25, Breakpoints.max)', () => {
            expect(() => index_1.getColumnsWidthForBreakpoint(25, index_1.Breakpoints.max)).toThrowError();
        });
        test('getColumnsWidthForBreakpoint(1.4, Breakpoints.max)', () => {
            expect(() => index_1.getColumnsWidthForBreakpoint(1.4, index_1.Breakpoints.max)).toThrowError();
        });
    });
    describe('hexColorToRgba', () => {
        test('returns fallback value 1 if passed alpha value is undefined', () => {
            expect(index_1.hexColorToRgba('#fff')).toBe('rgba(255,255,255,1)');
            expect(index_1.hexColorToRgba('#fff', undefined)).toBe('rgba(255,255,255,1)');
        });
        test('returns fallback alpha value 1 if passed value is invalid', () => {
            expect(index_1.hexColorToRgba('#fff', -1)).toBe('rgba(255,255,255,1)');
            expect(index_1.hexColorToRgba('#fff', 1.5)).toBe('rgba(255,255,255,1)');
        });
        test('returns fallback rgba value (transparent) if passed hex is invalid', () => {
            expect(index_1.hexColorToRgba('#fafaa', 1)).toBe('rgba(0,0,0,0)');
            expect(index_1.hexColorToRgba('#FF', 1)).toBe('rgba(0,0,0,0)');
            expect(index_1.hexColorToRgba('abc')).toBe('rgba(0,0,0,0)');
            expect(index_1.hexColorToRgba('#010101000', 0)).toBe('rgba(0,0,0,0)');
        });
        test('returns fallback rgba value if passed hex is invalid', () => {
            expect(index_1.hexColorToRgba('wurst')).toBe('rgba(0,0,0,0)');
        });
        test('returns given fallback option if passed hex is invalid', () => {
            expect(index_1.hexColorToRgba('wurst', { alpha: 0.3 })).toBe('rgba(0,0,0,0.3)');
        });
        test('returns fallback alpha if passed hex and alpha are invalid', () => {
            expect(index_1.hexColorToRgba('wurst', { alpha: 7 })).toBe('rgba(0,0,0,0)');
        });
        test('returns fallback rgb and alpha if passed hex and alpha are invalid', () => {
            expect(index_1.hexColorToRgba('wurst', { alpha: 7, rgbFallback: { r: 1, g: 2, b: 3 } })).toBe('rgba(1,2,3,0)');
        });
        test('returns fallback rgb and alpha if passed hex is invalid', () => {
            expect(index_1.hexColorToRgba('wurst', {
                alpha: 0.3,
                rgbFallback: { r: 1, g: 2, b: 3 }
            })).toBe('rgba(1,2,3,0.3)');
        });
        test('returns fallback rgba if passed hex and alpha are invalid', () => {
            expect(index_1.hexColorToRgba('wurst', {
                alpha: 7,
                rgbFallback: { r: 1, g: 2, b: 3 },
                rgbaFallback: 'initial'
            })).toBe('initial');
        });
        test('returns fallback rgba if passed hex is invalid', () => {
            expect(index_1.hexColorToRgba('wurst', {
                alpha: 0.3,
                rgbFallback: { r: 1, g: 2, b: 3 },
                rgbaFallback: 'initial'
            })).toBe('initial');
        });
        test('returns correct hex -> rgba converted values for valid inputs', () => {
            expect(index_1.hexColorToRgba('#000000', 0.1)).toBe('rgba(0,0,0,0.1)');
            expect(index_1.hexColorToRgba('#FFF', 0.05)).toBe('rgba(255,255,255,0.05)');
            expect(index_1.hexColorToRgba('#fafafa', 0.3)).toBe('rgba(250,250,250,0.3)');
            expect(index_1.hexColorToRgba('#ABA')).toBe('rgba(170,187,170,1)');
        });
    });
});
