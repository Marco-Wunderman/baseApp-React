"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const ReactDOM = __importStar(require("react-dom"));
class DOMNodeExposer extends React.Component {
    linkWithOtherElements(entry) {
        const typedWindow = window;
        if (!typedWindow.elementRefs) {
            return;
        }
        Object.entries(typedWindow.elementRefs).forEach(elementRefEntry => {
            const elementGroup = elementRefEntry[1];
            const elementKey = elementRefEntry[0];
            elementGroup.forEach(elementRef => {
                if (elementRef.domNode === entry.domNode &&
                    elementRef.domNode !== null) {
                    return;
                }
                if (elementRef.domNode && elementRef.domNode.contains(entry.domNode)) {
                    if (!elementRef.containedRefs[this.props.name]) {
                        elementRef.containedRefs[this.props.name] = [];
                    }
                    elementRef.containedRefs[this.props.name].push(entry);
                }
                if (entry.domNode && entry.domNode.contains(elementRef.domNode)) {
                    if (!entry.containedRefs[elementKey]) {
                        entry.containedRefs[elementKey] = [];
                    }
                    entry.containedRefs[elementKey].push(elementRef);
                }
            });
        });
    }
    unlinkFromOtherElements(entry) {
        const typedWindow = window;
        if (!typedWindow.elementRefs) {
            return;
        }
        Object.values(typedWindow.elementRefs).forEach(elementGroup => {
            elementGroup.forEach(elementRef => {
                if (!elementRef.containedRefs ||
                    !elementRef.containedRefs[this.props.name]) {
                    return;
                }
                const indexOfElement = elementRef.containedRefs[this.props.name].findIndex(child => child === entry);
                if (indexOfElement > -1) {
                    elementRef.containedRefs[this.props.name].splice(indexOfElement, 1);
                }
            });
        });
    }
    componentDidMount() {
        if (process.env.NODE_ENV !== 'production') {
            const typedWindow = window;
            // We need to disable this rule here because the whole idea of this component is that we expose the dom-node itself.
            // eslint-disable-next-line react/no-find-dom-node
            const element = ReactDOM.findDOMNode(this);
            if (!typedWindow.elementRefs) {
                typedWindow.elementRefs = {};
            }
            if (!typedWindow.elementRefs[this.props.name]) {
                typedWindow.elementRefs[this.props.name] = [];
            }
            const elementReference = { domNode: element, containedRefs: {} };
            this.setState({ elementReference });
            typedWindow.elementRefs[this.props.name].push(elementReference);
            this.linkWithOtherElements(elementReference);
        }
    }
    componentWillUnmount() {
        if (process.env.NODE_ENV !== 'production') {
            const typedWindow = window;
            if (!this.state.elementReference || !typedWindow.elementRefs) {
                return;
            }
            const indexOfElement = typedWindow.elementRefs[this.props.name].findIndex(entry => entry === this.state.elementReference);
            this.unlinkFromOtherElements(this.state.elementReference);
            if (indexOfElement > -1) {
                typedWindow.elementRefs[this.props.name].splice(indexOfElement, 1);
            }
        }
    }
    componentDidUpdate() {
        const typedWindow = window;
        // We need to disable this rule here because the whole idea of this component is that we expose the dom-node itself.
        // eslint-disable-next-line react/no-find-dom-node
        const newDomNode = ReactDOM.findDOMNode(this);
        if (!typedWindow.elementRefs) {
            return;
        }
        if (newDomNode === this.state.elementReference.domNode) {
            return;
        }
        this.setState({
            elementReference: Object.assign({}, this.state.elementReference, { domNode: newDomNode })
        });
        const elementReference = typedWindow.elementRefs[this.props.name].find(entry => entry === this.state.elementReference);
        if (!elementReference) {
            return;
        }
        elementReference.domNode = newDomNode;
    }
    render() {
        return this.props.children;
    }
}
exports.DOMNodeExposer = DOMNodeExposer;
